{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SSAFY/Desktop/panaxtos/front/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: ['query'],\r\n        datasourceUrl: process.env.DATABASE_URL || 'file:./dev.db'\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACT,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACb,KAAK;QAAC;KAAQ;IACd,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI;AAC/C;AAEJ,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/SSAFY/Desktop/panaxtos/front/app/api/reviews/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { getTokenFromRequest, verifyToken } from '@/lib/jwt';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nconst DATA_FILE_PATH = path.join(process.cwd(), 'data', 'reviews.json');\r\n\r\nfunction readJsonData() {\r\n    if (!fs.existsSync(DATA_FILE_PATH)) return [];\r\n    const fileData = fs.readFileSync(DATA_FILE_PATH, 'utf-8');\r\n    return JSON.parse(fileData);\r\n}\r\n\r\nfunction writeJsonData(data: any[]) {\r\n    const dir = path.dirname(DATA_FILE_PATH);\r\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\r\n    fs.writeFileSync(DATA_FILE_PATH, JSON.stringify(data, null, 2));\r\n}\r\n\r\n// GET /api/reviews/[id]\r\nexport async function GET(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ id: string }> }\r\n) {\r\n    const { id } = await params;\r\n    try {\r\n        let review;\r\n        try {\r\n            review = await prisma.review.findUnique({\r\n                where: { id: parseInt(id) }\r\n            });\r\n        } catch (e) {\r\n            console.warn('Prisma failed, falling back to JSON');\r\n            const allData = readJsonData();\r\n            review = allData.find((r: any) => r.id === parseInt(id));\r\n        }\r\n\r\n        if (!review) {\r\n            return NextResponse.json({ error: 'Not found' }, { status: 404 });\r\n        }\r\n        return NextResponse.json(review);\r\n    } catch (error) {\r\n        return NextResponse.json({ error: 'Failed to fetch review' }, { status: 500 });\r\n    }\r\n}\r\n\r\n// PUT /api/reviews/[id] - user edit with password verification\r\nexport async function PUT(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ id: string }> }\r\n) {\r\n    const { id } = await params;\r\n    try {\r\n        const body = await request.json();\r\n        // Expect password field for verification\r\n        if (!body.password) {\r\n            return NextResponse.json({ error: 'Password required' }, { status: 400 });\r\n        }\r\n        // Fetch existing review to compare password\r\n        let existingReview;\r\n        try {\r\n            existingReview = await prisma.review.findUnique({ where: { id: parseInt(id) } });\r\n        } catch (e) {\r\n            console.warn('Prisma failed, falling back to JSON');\r\n            const allData = readJsonData();\r\n            existingReview = allData.find((r: any) => r.id === parseInt(id));\r\n        }\r\n        if (!existingReview) {\r\n            return NextResponse.json({ error: 'Not found' }, { status: 404 });\r\n        }\r\n        if (existingReview.password !== body.password) {\r\n            return NextResponse.json({ error: 'Incorrect password' }, { status: 403 });\r\n        }\r\n        // Remove password from update payload to avoid overwriting it unintentionally\r\n        const { password, ...updateData } = body;\r\n        let review;\r\n        try {\r\n            review = await prisma.review.update({\r\n                where: { id: parseInt(id) },\r\n                data: updateData,\r\n            });\r\n        } catch (e) {\r\n            console.warn('Prisma failed, falling back to JSON');\r\n            const allData = readJsonData();\r\n            const index = allData.findIndex((r: any) => r.id === parseInt(id));\r\n            if (index !== -1) {\r\n                allData[index] = { ...allData[index], ...updateData };\r\n                writeJsonData(allData);\r\n                review = allData[index];\r\n            }\r\n        }\r\n        return NextResponse.json(review);\r\n    } catch (error) {\r\n        return NextResponse.json({ error: 'Failed to update review' }, { status: 500 });\r\n    }\r\n}\r\n\r\n// DELETE /api/reviews/[id] - user delete with password verification\r\nexport async function DELETE(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ id: string }> }\r\n) {\r\n    const { id } = await params;\r\n    try {\r\n        const body = await request.json();\r\n        if (!body.password) {\r\n            return NextResponse.json({ error: 'Password required' }, { status: 400 });\r\n        }\r\n        // Fetch existing review to verify password\r\n        let existingReview;\r\n        try {\r\n            existingReview = await prisma.review.findUnique({ where: { id: parseInt(id) } });\r\n        } catch (e) {\r\n            console.warn('Prisma failed, falling back to JSON');\r\n            const allData = readJsonData();\r\n            existingReview = allData.find((r: any) => r.id === parseInt(id));\r\n        }\r\n        if (!existingReview) {\r\n            return NextResponse.json({ error: 'Not found' }, { status: 404 });\r\n        }\r\n        if (existingReview.password !== body.password) {\r\n            return NextResponse.json({ error: 'Incorrect password' }, { status: 403 });\r\n        }\r\n        // Perform deletion\r\n        try {\r\n            await prisma.review.delete({ where: { id: parseInt(id) } });\r\n        } catch (e) {\r\n            console.warn('Prisma failed, falling back to JSON');\r\n            const allData = readJsonData();\r\n            const newData = allData.filter((r: any) => r.id !== parseInt(id));\r\n            writeJsonData(newData);\r\n        }\r\n        return new NextResponse(null, { status: 204 });\r\n    } catch (error) {\r\n        return NextResponse.json({ error: 'Failed to delete review' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}